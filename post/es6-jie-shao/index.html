<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
<title>
    雁南飞无留意
</title>
<!--[if lt IE 9]><script src="//cdn.bootcss.com/html5shiv/r29/html5.js"></script><![endif]-->
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport" />
<meta http-equiv="x-dns-prefetch-control" content="on">
<link rel="dns-prefetch" href="https://fastly.jsdelivr.net">
<meta name="author" content="雁南飞无留意">
<meta name="description" content="种一棵树最好的时间是十年前,其次是现在。o(*￣▽￣*)ブ">
<meta name="keywords" content="个人博客">
<script async src="//instant.page/3.0.0" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>
<link rel="stylesheet" href="https://2022FuGui.github.io/styles/main.css" />
<link href="https://fastly.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
<script type="text/javascript" src="https://apps.bdimg.com/libs/jquery/1.7.1/jquery.min.js"></script>

    <link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/itjoker233/Gridea-theme-Chic/assets/media/css/style.min.css" />
    <script src="https://fastly.jsdelivr.net/gh/itjoker233/Gridea-theme-Chic/assets/media/script/tocbot.min.js"></script>
    <script src="https://fastly.jsdelivr.net/gh/itjoker233/Gridea-theme-Chic/assets/media/script/script.min.js"></script>
    <script src="https://fastly.jsdelivr.net/gh/itjoker233/Gridea-theme-Chic/assets/media/script/icon.min.js"></script>
    
            <script src="https://fastly.jsdelivr.net/gh/ITJoker233/ITJoker233.github.io@latest/CDN/js/Card/prism.min.js"></script>
            <link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/ITJoker233/ITJoker233.github.io@latest/CDN/css/Card/prism.min.css" />
            <link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/katex@0.10.1/dist/katex.min.css">
            <script defer src="https://fastly.jsdelivr.net/npm/katex@0.10.1/dist/katex.min.js"></script>
            
                <!--点击特效-->
                <script src="https://fastly.jsdelivr.net/gh/ITJoker233/ITJoker233.github.io@latest/CDN/js/love.min.js"></script>
                
                        <!--CDN样式-->
                        <script src="https://fastly.jsdelivr.net/gh/ITJoker233/ITJoker233.github.io@latest/CDN/js/hit-kounter-lc-0.3.0.js"></script>
                        <script src="https://cdn1.lncld.net/static/js/av-min-1.5.0.js"></script>
                        
                            <script>
                                (function() {
                                    var bp = document.createElement('script');
                                    var curProtocol = window.location.protocol.split(':')[0];
                                    if (curProtocol === 'https') {
                                        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
                                    } else {
                                        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
                                    }
                                    var s = document.getElementsByTagName("script")[0];
                                    s.parentNode.insertBefore(bp, s);
                                })();
                            </script>
                            
</head>

<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo">
                <a href="https://2022FuGui.github.io">
                    雁南飞无留意
                </a>
            </div>
            <div id="tp-weather-widget"></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/">
                        首页
                    </a>
                    
                    <a class="menu-item" href="/archives">
                        文章
                    </a>
                    
                    <a class="menu-item" href="/tags">
                        标签
                    </a>
                    
                    <a class="menu-item" href="https://2022FuGui.github.io/post/about">
                        关于本站
                    </a>
                    
                        <input id="switch_default" type="checkbox" class="switch_default">
                        <label for="switch_default" class="toggleBtn"></label>
            </div>
            <form id="gridea-search-form" data-update="1729699091091" action="/search/index.html">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" autofocus="true" placeholder="Search...">
            </form>
        </div>
    </nav>

    
        <nav class="navbar-mobile" id="nav-mobile">
            <div class="container">
                <div class="navbar-header">
                    <div>
                        <a href="https://2022FuGui.github.io">
                            雁南飞无留意
                        </a>
                        <!--en-->
                        <a id="mobile-toggle-theme-en" class="a en">&nbsp;Dark</a>
                        <!--zh-->
                        <a id="mobile-toggle-theme-zh" class="a zh">&nbsp;&#x6697;&#x9ED1;</a>
                    </div>
                    <form id="gridea-search-form" data-update="1729699091091" action="/search/index.html">
                        <input class="search-input" autocomplete="off" spellcheck="false" name="q" autofocus="true" placeholder="Search...">
                    </form>
                    <!--en-->
                    <div class="menu-toggle" id="menu-toggle-en" onclick="mobileBtn()">&#9776; Menu</div>
                    <!--zh-->
                    <div class="menu-toggle" id="menu-toggle-zh" onclick="mobileBtn()">&#9776; &#x83DC;&#x5355;</div>

                </div>
                <div class="menu" id="mobile-menu">
                    
                        <a class="menu-item" href="/">
                            首页
                        </a>
                        
                        <a class="menu-item" href="/archives">
                            文章
                        </a>
                        
                        <a class="menu-item" href="/tags">
                            标签
                        </a>
                        
                        <a class="menu-item" href="https://2022FuGui.github.io/post/about">
                            关于本站
                        </a>
                        
                </div>
            </div>
        </nav>
</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementById("menu-toggle-en");
        var toggleMenu_zh = document.getElementById("menu-toggle-zh");

        var mobileMenu = document.getElementById("mobile-menu");
        if (toggleMenu.display != "none") {
            if (toggleMenu.classList.contains("active")) {
                toggleMenu.classList.remove("active")
                mobileMenu.classList.remove("active")
            } else {
                toggleMenu.classList.add("active")
                mobileMenu.classList.add("active")
            }
        } else if (toggleMenu_zh.display != "none") {
            if (toggleMenu_zh.classList.contains("active")) {
                toggleMenu_zh.classList.remove("active")
                mobileMenu.classList.remove("active")
            } else {
                toggleMenu_zh.classList.add("active")
                mobileMenu.classList.add("active")
            }
        }

    }
</script>



    <script>
        (function(a, h, g, f, e, d, c, b) {
            b = function() {
                d = h.createElement(g);
                c = h.getElementsByTagName(g)[0];
                d.src = e;
                d.charset = "utf-8";
                d.async = 1;
                c.parentNode.insertBefore(d, c)
            };
            a["SeniverseWeatherWidgetObject"] = f;
            a[f] || (a[f] = function() {
                (a[f].q = a[f].q || []).push(arguments)
            });
            a[f].l = +new Date();
            if (a.attachEvent) {
                a.attachEvent("onload", b)
            } else {
                a.addEventListener("load", b, false)
            }
        }(window, document, "script", "SeniverseWeatherWidget", "//cdn.sencdn.com/widget2/static/js/bundle.js?t=" + parseInt((new Date().getTime() / 100000000).toString(), 10)));
        window.SeniverseWeatherWidget('show', {
            flavor: "slim",
            location: "WWEFQFPJZ7T8",
            geolocation: true,
            language: "auto",
            unit: "c",
            theme: "auto",
            token: "61bcc333-3305-4728-9465-6785274bb0a3",
            hover: "enabled",
            container: "tp-weather-widget"
        })
    </script>
    
            <div class="main">
                <div class="container">
                    <article class="post-wrap">
                        <header class="post-header">
                            <h1 class="post-title">
                                ES6
                            </h1>
                            
                                    <!--zh-->
                                    <div class="post-meta zh">
                                        &#x4F5C;&#x8005;:
                                        <a itemprop="author" rel="author" href="/">
                                            雁南飞无留意
                                        </a>
                                        <span class="post-time">&#x65E5;&#x671F;: <a href="#">2023-09-19</a></span>
                                        <span class="post-readtime">&#x9605;&#x8BFB;&#x65F6;&#x95F4;:<a
                                    href="#">50.3
                                    &#x5206;&#x949F;</a></span>
                                        <span class="post-words">&#x5B57;&#x6570;:<a href="#">12727</a></span>
                                        
                                            <span class="post-category">&#x5206;&#x7C7B;:
                                
                                <a href="https://2022FuGui.github.io/tag/wTb2n121Vj/">JS</a>
                                
                                <a href="https://2022FuGui.github.io/tag/5d3oKlLxgj/">前端</a>
                                
                            </span>
                                            
                                                阅读量:
                                                <span data-hk-page="current"> - </span>
                                                
                                    </div>
                                    
                        </header>
                        
                        <div class="post-content">
                            <h1 id="01-es6-介绍">01 【ES6 介绍】</h1>
<p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p>
<h2 id="1ecmascript-和-javascript-的关系">1.ECMAScript 和 JavaScript 的关系</h2>
<p>一个常见的问题是，ECMAScript 和 JavaScript 到底是什么关系？</p>
<p>要讲清楚这个问题，需要回顾历史。1996 年 11 月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给标准化组织 ECMA，希望这种语言能够成为国际标准。次年，ECMA 发布 262 号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript，这个版本就是 1.0 版。</p>
<p>该标准从一开始就是针对 JavaScript 语言制定的，但是之所以不叫 JavaScript，有两个原因。一是商标，Java 是 Sun 公司的商标，根据授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且 JavaScript 本身也已经被 Netscape 公司注册为商标。二是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。</p>
<p>因此，ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 JScript 和 ActionScript）。日常场合，这两个词是可以互换的。</p>
<h2 id="2es6-与-ecmascript-2015-的关系">2.ES6 与 ECMAScript 2015 的关系</h2>
<p>ECMAScript 2015（简称 ES2015）这个词，也是经常可以看到的。它与 ES6 是什么关系呢？</p>
<p>2011 年，ECMAScript 5.1 版发布后，就开始制定 6.0 版了。因此，ES6 这个词的原意，就是指 JavaScript 语言的下一个版本。</p>
<p>但是，因为这个版本引入的语法功能太多，而且制定过程当中，还有很多组织和个人不断提交新功能。事情很快就变得清楚了，不可能在一个版本里面包括所有将要引入的功能。常规的做法是先发布 6.0 版，过一段时间再发 6.1 版，然后是 6.2 版、6.3 版等等。</p>
<p>但是，标准的制定者不想这样做。他们想让标准的升级成为常规流程：任何人在任何时候，都可以向标准委员会提交新语法的提案，然后标准委员会每个月开一次会，评估这些提案是否可以接受，需要哪些改进。如果经过多次会议以后，一个提案足够成熟了，就可以正式进入标准了。这就是说，标准的版本升级成为了一个不断滚动的流程，每个月都会有变动。</p>
<p>标准委员会最终决定，标准在每年的 6 月份正式发布一次，作为当年的正式版本。接下来的时间，就在这个版本的基础上做改动，直到下一年的 6 月份，草案就自然变成了新一年的版本。这样一来，就不需要以前的版本号了，只要用年份标记就可以了。</p>
<p>ES6 的第一个版本，就这样在 2015 年 6 月发布了，正式名称就是《ECMAScript 2015 标准》（简称 ES2015）。2016 年 6 月，小幅修订的《ECMAScript 2016 标准》（简称 ES2016）如期发布，这个版本可以看作是 ES6.1 版，因为两者的差异非常小（只新增了数组实例的<code>includes</code>方法和指数运算符），基本上是同一个标准。根据计划，2017 年 6 月发布 ES2017 标准。</p>
<p>因此，ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。本书中提到 ES6 的地方，一般是指 ES2015 标准，但有时也是泛指“下一代 JavaScript 语言”。</p>
<h2 id="3es6简介">3.ES6简介</h2>
<p>ES6 = ECMAScript 这门标准的第 6 代版本（2015）。</p>
<ul>
<li>ECMAScript 是语言的标准</li>
<li>6 是版本号</li>
</ul>
<!-- more -->
<p>ECMA：欧洲计算机制造商协会</p>
<p>具体内容：语法 + API</p>
<p>历史版本：ES1——&gt;3、ES5——&gt;6（ES4 被废弃了）</p>
<p>我们目前使用 JS 的大部分内容都是 ES3 <strong>的部分</strong>。</p>
<p>ES 与 JS 的关系：<code>JavaScript(浏览器端) = ESMAScript(语法+API) + DOM + BOM</code></p>
<p>ES6 的兼容性：</p>
<ul>
<li>主流浏览器的最新版本几乎都全部支持 ES6</li>
<li>IE 老版本等不支持的浏览器，可以使用 Babel 转码</li>
<li><strong>总之，请放心大胆地使用 ES6</strong></li>
</ul>
<h1 id="02-let和const">02 【let和const】</h1>
<h2 id="1let-命令">1.let 命令</h2>
<h3 id="11-基本用法">1.1 基本用法</h3>
<p>ES6 新增了<code>let</code>命令，用来声明变量。它的用法类似于<code>var</code>，但是所声明的变量，只在<code>let</code>命令所在的代码块内有效。</p>
<pre><code class="language-js">{
  let a = 10;
  var b = 1;
}

a // ReferenceError: a is not defined.
b // 1
</code></pre>
<p>上面代码在代码块之中，分别用<code>let</code>和<code>var</code>声明了两个变量。然后在代码块之外调用这两个变量，结果<code>let</code>声明的变量报错，<code>var</code>声明的变量返回了正确的值。这表明，<code>let</code>声明的变量只在它所在的代码块有效。</p>
<p><code>for</code>循环的计数器，就很合适使用<code>let</code>命令。</p>
<pre><code class="language-js">for (let i = 0; i &lt; 10; i++) {
  // ...
}

console.log(i);
// ReferenceError: i is not defined
</code></pre>
<p>上面代码中，计数器<code>i</code>只在<code>for</code>循环体内有效，在循环体外引用就会报错。</p>
<p>下面的代码如果使用<code>var</code>，最后输出的是<code>10</code>。</p>
<pre><code class="language-js">var a = [];
for (var i = 0; i &lt; 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 10
</code></pre>
<p>上面代码中，变量<code>i</code>是<code>var</code>命令声明的，在全局范围内都有效，所以全局只有一个变量<code>i</code>。每一次循环，变量<code>i</code>的值都会发生改变，而循环内被赋给数组<code>a</code>的函数内部的<code>console.log(i)</code>，里面的<code>i</code>指向的就是全局的<code>i</code>。也就是说，所有数组<code>a</code>的成员里面的<code>i</code>，指向的都是同一个<code>i</code>，导致运行时输出的是最后一轮的<code>i</code>的值，也就是 10。</p>
<p>如果使用<code>let</code>，声明的变量仅在块级作用域内有效，最后输出的是 6。</p>
<pre><code class="language-js">var a = [];
for (let i = 0; i &lt; 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 6
</code></pre>
<p>上面代码中，变量<code>i</code>是<code>let</code>声明的，当前的<code>i</code>只在本轮循环有效，所以每一次循环的<code>i</code>其实都是一个新的变量，所以最后输出的是<code>6</code>。你可能会问，如果每一轮循环的变量<code>i</code>都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量<code>i</code>时，就在上一轮循环的基础上进行计算。</p>
<p>另外，<code>for</code>循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p>
<pre><code class="language-js">for (let i = 0; i &lt; 3; i++) {
  let i = 'abc';
  console.log(i);
}
// abc
// abc
// abc
</code></pre>
<p>上面代码正确运行，输出了 3 次<code>abc</code>。这表明函数内部的变量<code>i</code>与循环变量<code>i</code>不在同一个作用域，有各自单独的作用域（同一个作用域不可使用 <code>let</code> 重复声明同一个变量）。</p>
<h3 id="12-不存在变量提升">1.2 不存在变量提升</h3>
<p><code>var</code>命令会发生“变量提升”现象，即变量可以在声明之前使用，值为<code>undefined</code>。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。</p>
<p>为了纠正这种现象，<code>let</code>命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p>
<pre><code class="language-js">// var 的情况
console.log(foo); // 输出undefined
var foo = 2;

// let 的情况
console.log(bar); // 报错ReferenceError
let bar = 2;
</code></pre>
<p>上面代码中，变量<code>foo</code>用<code>var</code>命令声明，会发生变量提升，即脚本开始运行时，变量<code>foo</code>已经存在了，但是没有值，所以会输出<code>undefined</code>。变量<code>bar</code>用<code>let</code>命令声明，不会发生变量提升。这表示在声明它之前，变量<code>bar</code>是不存在的，这时如果用到它，就会抛出一个错误。</p>
<h3 id="13-暂时性死区">1.3 暂时性死区</h3>
<p>只要作用域内存在 let、const，它们所声明的变量或常量就自动 “绑定” 这个区域，不再受到外部作用域的影响。</p>
<pre><code class="language-javascript">let a = 2;
function func() {
    console.log(a);        // 报错
    let a = 1;
}
func();
</code></pre>
<pre><code class="language-javascript">let a = 2;
function func() {
    console.log(a);        // 2
}
func();
</code></pre>
<p><strong>即：只要作用域内出现了同名的 let 或 const，那么就会去找这个量（向前找），如果找不到也不会跳去外部找，只会直接报错！</strong></p>
<blockquote>
<p>只要我们遵守 “<strong>先声明后使用</strong>”，那么其实就基本不会遇到变量提升及暂时性死区问题。</p>
</blockquote>
<h3 id="14-不允许重复声明">1.4 不允许重复声明</h3>
<p><code>let</code>不允许在相同作用域内，重复声明同一个变量。</p>
<pre><code class="language-js">// 报错
function func() {
  let a = 10;
  var a = 1;
}

// 报错
function func() {
  let a = 10;
  let a = 1;
}
</code></pre>
<p>因此，不能在函数内部重新声明参数。</p>
<pre><code class="language-js">function func(arg) {
  let arg;
}
func() // 报错

function func(arg) {
  {
    let arg;
  }
}
func() // 不报错
</code></pre>
<h2 id="2块级作用域">2.块级作用域</h2>
<h3 id="21-为什么需要块级作用域">2.1 为什么需要块级作用域？</h3>
<p>ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。</p>
<p>第一种场景，内层变量可能会覆盖外层变量。</p>
<pre><code class="language-js">var tmp = new Date();

function f() {
  console.log(tmp);
  if (false) {
    var tmp = 'hello world';
  }
}

f(); // undefined
</code></pre>
<p>上面代码的原意是，<code>if</code>代码块的外部使用外层的<code>tmp</code>变量，内部使用内层的<code>tmp</code>变量。但是，函数<code>f</code>执行后，输出结果为<code>undefined</code>，原因在于变量提升，导致内层的<code>tmp</code>变量覆盖了外层的<code>tmp</code>变量。</p>
<p>第二种场景，用来计数的循环变量泄露为全局变量。</p>
<pre><code>var s = 'hello';

for (var i = 0; i &lt; s.length; i++) {
  console.log(s[i]);
}

console.log(i); // 5
</code></pre>
<p>上面代码中，变量<code>i</code>只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。</p>
<h3 id="22-es6-的块级作用域">2.2 ES6 的块级作用域</h3>
<p><code>let</code>实际上为 JavaScript 新增了块级作用域。</p>
<ul>
<li>
<p>作用域链：内层作用域 ——&gt; 外层作用域 ——&gt; 全局作用域</p>
</li>
<li>
<p>块级作用域：除了对象 <code>{}</code>，函数 <code>{}</code>（函数作用域）之外的一切 <code>{}</code> 都属于块级作用域。</p>
</li>
</ul>
<pre><code class="language-js">function f1() {
  let n = 5;
  if (true) {
    let n = 10;
  }
  console.log(n); // 5
}
</code></pre>
<p>上面的函数有两个代码块，都声明了变量<code>n</code>，运行后输出 5。这表示外层代码块不受内层代码块的影响。如果两次都使用<code>var</code>定义变量<code>n</code>，最后输出的值才是 10。</p>
<p>ES6 允许块级作用域的任意嵌套。</p>
<pre><code class="language-js">{{{{
  {let insane = 'Hello World'}
  console.log(insane); // 报错
}}}};
</code></pre>
<p>上面代码使用了一个五层的块级作用域，每一层都是一个单独的作用域。第四层作用域无法读取第五层作用域的内部变量。</p>
<p>内层作用域可以定义外层作用域的同名变量。</p>
<pre><code class="language-js">{{{{
  let insane = 'Hello World';
  {let insane = 'Hello World'}
}}}};
</code></pre>
<p>块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 IIFE）不再必要了。</p>
<pre><code class="language-js">// IIFE 写法
(function () {
  var tmp = ...;
  ...
}());

// 块级作用域写法
{
  let tmp = ...;
  ...
}
</code></pre>
<h3 id="23-块级作用域与函数声明">2.3 块级作用域与函数声明</h3>
<p>函数能不能在块级作用域之中声明？这是一个相当令人混淆的问题。</p>
<p>ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。</p>
<pre><code class="language-js">// 情况一
if (true) {
  function f() {}
}

// 情况二
try {
  function f() {}
} catch(e) {
  // ...
}
</code></pre>
<p>上面两种函数声明，根据 ES5 的规定都是非法的。</p>
<p>但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。</p>
<p>ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于<code>let</code>，在块级作用域之外不可引用。</p>
<pre><code class="language-js">function f() { console.log('I am outside!'); }

(function () {
  if (false) {
    // 重复声明一次函数f
    function f() { console.log('I am inside!'); }
  }

  f();
}());
</code></pre>
<p>上面代码在 ES5 中运行，会得到“I am inside!”，因为在<code>if</code>内声明的函数<code>f</code>会被提升到函数头部，实际运行的代码如下。</p>
<pre><code class="language-js">// ES5 环境
function f() { console.log('I am outside!'); }

(function () {
  function f() { console.log('I am inside!'); }
  if (false) {
  }
  f();
}());
</code></pre>
<p>ES6 就完全不一样了，理论上会得到“I am outside!”。因为块级作用域内声明的函数类似于<code>let</code>，对作用域之外没有影响。但是，如果你真的在 ES6 浏览器中运行一下上面的代码，是会报错的，这是为什么呢？</p>
<pre><code class="language-js">// 浏览器的 ES6 环境
function f() { console.log('I am outside!'); }

(function () {
  if (false) {
    // 重复声明一次函数f
    function f() { console.log('I am inside!'); }
  }

  f();
}());
// Uncaught TypeError: f is not a function
</code></pre>
<p>上面的代码在 ES6 浏览器中，都会报错。</p>
<p>原来，如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。</p>
<ul>
<li>允许在块级作用域内声明函数。</li>
<li>函数声明类似于<code>var</code>，即会提升到全局作用域或函数作用域的头部。</li>
<li>同时，函数声明还会提升到所在的块级作用域的头部。</li>
</ul>
<p>注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作<code>let</code>处理。</p>
<p>根据这三条规则，浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于<code>var</code>声明的变量。上面的例子实际运行的代码如下。</p>
<pre><code class="language-js">// 浏览器的 ES6 环境
function f() { console.log('I am outside!'); }
(function () {
  var f = undefined;
  if (false) {
    function f() { console.log('I am inside!'); }
  }

  f();
}());
// Uncaught TypeError: f is not a function
</code></pre>
<p>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</p>
<pre><code class="language-js">// 块级作用域内部的函数声明语句，建议不要使用
{
  let a = 'secret';
  function f() {
    return a;
  }
}

// 块级作用域内部，优先使用函数表达式
{
  let a = 'secret';
  let f = function () {
    return a;
  };
}
</code></pre>
<p>另外，还有一个需要注意的地方。ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。</p>
<pre><code class="language-js">// 第一种写法，报错
if (true) let x = 1;

// 第二种写法，不报错
if (true) {
  let x = 1;
}
</code></pre>
<p>上面代码中，第一种写法没有大括号，所以不存在块级作用域，而<code>let</code>只能出现在当前作用域的顶层，所以报错。第二种写法有大括号，所以块级作用域成立。</p>
<p>函数声明也是如此，严格模式下，函数只能声明在当前作用域的顶层。</p>
<pre><code class="language-js">// 不报错
'use strict';
if (true) {
  function f() {}
}

// 报错
'use strict';
if (true)
  function f() {}
</code></pre>
<h2 id="3const-命令">3.const 命令</h2>
<h3 id="31-基本用法">3.1 基本用法</h3>
<p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。</p>
<pre><code class="language-js">const PI = 3.1415;
PI // 3.1415

PI = 3;
// TypeError: Assignment to constant variable.
</code></pre>
<p>上面代码表明改变常量的值会报错。</p>
<p><code>const</code>声明的变量不得改变值，这意味着，<code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值。</p>
<pre><code class="language-js">const foo;
// SyntaxError: Missing initializer in const declaration
</code></pre>
<p>上面代码表示，对于<code>const</code>来说，只声明不赋值，就会报错。</p>
<p><code>const</code>的作用域与<code>let</code>命令相同：只在声明所在的块级作用域内有效。</p>
<pre><code class="language-js">if (true) {
  const MAX = 5;
}

MAX // Uncaught ReferenceError: MAX is not defined
</code></pre>
<p><code>const</code>命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p>
<pre><code class="language-js">if (true) {
  console.log(MAX); // ReferenceError
  const MAX = 5;
}
</code></pre>
<p>上面代码在常量<code>MAX</code>声明之前就调用，结果报错。</p>
<p><code>const</code>声明的常量，也与<code>let</code>一样不可重复声明。</p>
<pre><code class="language-js">var message = &quot;Hello!&quot;;
let age = 25;

// 以下两行都会报错
const message = &quot;Goodbye!&quot;;
const age = 30;
</code></pre>
<h3 id="32-本质">3.2 本质</h3>
<p><code>const</code>实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，<code>const</code>只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p>
<pre><code class="language-js">const foo = {};

// 为 foo 添加一个属性，可以成功
foo.prop = 123;
foo.prop // 123

// 将 foo 指向另一个对象，就会报错
foo = {}; // TypeError: &quot;foo&quot; is read-only
</code></pre>
<p>上面代码中，常量<code>foo</code>储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把<code>foo</code>指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。</p>
<p>下面是另一个例子。</p>
<pre><code class="language-js">const a = [];
a.push('Hello'); // 可执行
a.length = 0;    // 可执行
a = ['Dave'];    // 报错
</code></pre>
<p>上面代码中，常量<code>a</code>是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给<code>a</code>，就会报错。</p>
<h3 id="33-window-对象的属性和方法全局作用域中">3.3  window 对象的属性和方法（全局作用域中）</h3>
<p>全局作用域中，<code>var</code> 声明的变量，<code>function</code> 声明的函数，会自动变成 window 对象的属性或方法。</p>
<pre><code class="language-javascript">var age = 18;
function add() {}
console.log(window.age);            // 18
console.log(window.add === add);     // true
</code></pre>
<pre><code class="language-javascript">let age = 18;
const add = function() {}
console.log(window.age);            // undefined
console.log(window.add === add);     // false
</code></pre>
<h3 id="34-什么时候用-let什么使用用-const">3.4 什么时候用 let，什么使用用 const</h3>
<p>原则：如果不知道用什么的时候，就用 const</p>
<p>原因：如果应该是常量，那么刚好符合需求。如果应该是变量，那么后来报错时，再来改为变量也为时不晚。同时，一开始就设置为常量还会避免真的需要为常量时，该值在后来被意外修改的情况。</p>
<h2 id="4let和const总结">4.let和const总结</h2>
<ol>
<li>let 声明的变量会产生块作用域，var 不会产生块作用域</li>
<li>const 声明的常量也会产生块作用域</li>
<li>不同代码块之间的变量无法互相访问</li>
<li>注意: 对象属性修改和数组元素变化不会出发 const 错误 （数组和对象存的是引用地址）</li>
<li>应用场景：声明对象类型使用 const，非对象类型声明选择 let</li>
<li>cosnt声明必须赋初始值，标识符一般为大写，值不允许修改。</li>
</ol>
<h2 id="5顶层对象的属性">5.顶层对象的属性</h2>
<p>顶层对象，在浏览器环境指的是<code>window</code>对象，在 Node 指的是<code>global</code>对象。ES5 之中，顶层对象的属性与全局变量是等价的。</p>
<pre><code class="language-js">window.a = 1;
a // 1

a = 2;
window.a // 2
</code></pre>
<p>上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。</p>
<p>顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，<code>window</code>对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。</p>
<p>ES6 为了改变这一点，一方面规定，为了保持兼容性，<code>var</code>命令和<code>function</code>命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，<code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。</p>
<pre><code class="language-js">var a = 1;
// 如果在 Node 的 REPL 环境，可以写成 global.a
// 或者采用通用方法，写成 this.a
window.a // 1

let b = 1;
window.b // undefined
</code></pre>
<p>上面代码中，全局变量<code>a</code>由<code>var</code>命令声明，所以它是顶层对象的属性；全局变量<code>b</code>由<code>let</code>命令声明，所以它不是顶层对象的属性，返回<code>undefined</code>。</p>
<h1 id="03解构赋值">03【解构赋值】</h1>
<h2 id="1数组的解构赋值">1.数组的解构赋值</h2>
<h3 id="11-原理">1.1 原理</h3>
<p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p>
<p>以前，为变量赋值，只能直接指定值。</p>
<pre><code class="language-js">let a = 1;
let b = 2;
let c = 3;
</code></pre>
<p>ES6 允许写成下面这样。</p>
<pre><code class="language-js">let [a, b, c] = [1, 2, 3];
</code></pre>
<p>上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。</p>
<ol>
<li>
<p>模式（结构）匹配 <code>[] = [1, 2, 3];</code></p>
</li>
<li>
<p>索引值相同的完成赋值 <code>const [a, b, c] = [1, 2, 3];</code></p>
</li>
<li>
<p>举例</p>
<pre><code class="language-javascript">const [a, [, , b], c] = [1, [2, 3, 4], 5];
console.log(a, b, c);    // 1 4 5
</code></pre>
</li>
</ol>
<h3 id="12-数组解构赋值的默认值">1.2 数组解构赋值的默认值</h3>
<p><strong>（1）默认值的基本用法</strong></p>
<pre><code class="language-javascript">const [a, b] = [];
console.log(a, b);    // undefined undefined

// ---------------------------------------
const [a = 1, b = 2] = [];
console.log(a, b);    // 1 2
</code></pre>
<p><strong>（2）默认值的生效条件</strong></p>
<p>只有当一个数组成员严格等于 (===) undefined 时，对应的默认值才会生效。</p>
<pre><code class="language-javascript">const [a = 1, b = 2] = [3, 0];        // 3 0
const [a = 1, b = 2] = [3, null];    // 3 null
const [a = 1, b = 2] = [3];            // 3 2
</code></pre>
<p><strong>（3）默认值表达式</strong></p>
<p>如果默认值是表达式，默认值表达式是惰性求值的（即：当无需用到默认值时，表达式是不会求值的）</p>
<pre><code class="language-javascript">const func = () =&gt; {
    return 24;
};

const [a = func()] = [1];    // 1
const [b = func()] = [];    // 24
</code></pre>
<h3 id="13-数组解构赋值的应用">1.3 数组解构赋值的应用</h3>
<p><strong>（1）arguments</strong></p>
<pre><code class="language-javascript">function func() {
    const [a, b] = arguments;
    console.log(a, b);    // 1 2
}
func(1, 2);
</code></pre>
<p><strong>（2）NodeList</strong></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;NodeList&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;script&gt;
    const [p1, p2, p3] = document.querySelectorAll('p');
    console.log(p1, p2, p3);
    /*
    &lt;p&gt;1&lt;/p&gt;
    &lt;p&gt;2&lt;/p&gt;
    &lt;p&gt;3&lt;/p&gt;
    */
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>（3）函数参数的解构赋值</strong></p>
<pre><code class="language-javascript">const array = [1, 1];
// const add = arr =&gt; arr[0] + arr[1];
const add = ([x = 0, y = 0]) =&gt; x + y;
console.log(add(array));    // 2
console.log(add([]));        // 0
</code></pre>
<p><strong>（4）交换变量的值</strong></p>
<pre><code class="language-javascript">let x = 2, y = 1;

// 原来
let tmp = x;
x = y;
y = tmp;

// 现在
[x, y] = [y, x];
// 理解：[x, y] = [2, 1]
console.log(x, y);
// 1 2
</code></pre>
<p><strong>（5）跳过某项值使用逗号隔开</strong></p>
<p>在解构数组时，可以忽略不需要解构的值，可以使用逗号对解构的数组进行忽略操作，这样就不需要声明更多的变量去存值了：</p>
<pre><code class="language-js">var [a, , , b] = [10, 20, 30, 40];
console.log(a);   // 10
console.log(b);   // 40
</code></pre>
<p>上面的例子中，在 a、b 中间用逗号隔开了两个值，这里怎么判断间隔几个值呢，可以看出逗号之间组成了多少间隔，就是间隔了多少个值。如果取值很少的情况下可以使用下标索引的方式来获取值。</p>
<p><strong>（6）剩余参数中的使用</strong></p>
<p>通常情况下，需要把剩余的数组项作为一个单独的数组，这个时候我们可以借助展开语法把剩下的数组中的值，作为一个单独的数组，如下：</p>
<pre><code class="language-js">var [a, b, ...rest] = [10, 20, 30, 40, 50];
console.log(a);     // 10
console.log(b);     // 20
console.log(rest);  // [30, 40, 50]
</code></pre>
<p>在 rest 的后面不能有 逗号 不然会报错，程序会认出你后面还有值。<code>...rest</code> 是剩余参数的解构，所以只能放在数组的最后，在它之后不能再有变量，否则则会报错。</p>
<h3 id="14-必须要分号的两种情况">1.4 必须要分号的两种情况</h3>
<pre><code class="language-js">// 1. 立即执行函数
// ;(function () { })();
// (function () { })();

// 2. 使用数组解构的时候
// const arr = [1, 2, 3]
const str = 'pink';
[1, 2, 3].map(function (item) {
  console.log(item)
})

let a = 1
let b = 2
  ;[b, a] = [a, b]

console.log(a, b)
</code></pre>
<h2 id="2对象的解构赋值">2.对象的解构赋值</h2>
<h3 id="21-原理">2.1 原理</h3>
<p>对象的解构和数组基本类似，对象解构的变量是在 <code>{}</code> 中定义的。对象没有索引，但对象有更明确的键，通过键可以很方便地去对象中取值。在 ES6 之前直接使用键取值已经很方便了：</p>
<pre><code class="language-js">var obj = { name: 'imooc', age: 7 };
var name = obj.name;  // imooc
var age = obj.age;    // 7
</code></pre>
<p>但是在 ES6 中通过解构的方式，更加简洁地对取值做了简化，不需要通过点操作增加额外的取值操作。</p>
<pre><code class="language-js">var obj = { name: 'imooc', age: 7 };
var { name, age } = obj;  // name: imooc, age: 7
</code></pre>
<p>在 <code>{}</code> 直接声明 name 和 age 用逗号隔开即可得到目标对象上的值，完成声明赋值操作。</p>
<ol>
<li>模式（结构）匹配 <code>{} = {};</code></li>
<li>属性名相同的完成赋值 <code>const {name, age} = {name: 'jerry', age: 18};</code> 或 <code>const {age, name} = {name: 'jerry', age: 18};</code></li>
</ol>
<h3 id="22-对象解构赋值的默认值">2.2 对象解构赋值的默认值</h3>
<ol>
<li>
<p>对象的属性值严格等于 undefined 时，对应的默认值才会生效。</p>
</li>
<li>
<p>如果默认值是表达式，默认值表达式是惰性求值的。</p>
</li>
</ol>
<p>对象的默认值和数组的默认值一样，只能通过严格相等运算符（===）来进行判断，只有当一个对象的属性值严格等于 <code>undefined</code>，默认值才会生效。</p>
<pre><code class="language-js">var {a = 10, b = 5} = {a: 3};                 // a = 3, b = 5
var {a = 10, b = 5} = {a: 3, b: undefined};   // a = 3, b = 5
var {a = 10, b = 5} = {a: 3, b: null};        // a = 3, b = null
</code></pre>
<p>所以这里的第二项 b 的值是默认值，第三项的 <code>null === undefined</code> 的值为 false，所以 b 的值为 null。</p>
<h3 id="23-重命名属性">2.3 重命名属性</h3>
<p>在对象解构出来的变量不是我们想要的变量命名，这时我们需要对它进行重命名。</p>
<pre><code class="language-js">var {a:x = 8, b:y = 3} = {a: 2};

console.log(x); // 2
console.log(y); // 3
</code></pre>
<p>这里把 a 和 b 的变量名重新命名为 x 和 y。</p>
<h3 id="24-对象解构赋值的应用">2.4 对象解构赋值的应用</h3>
<p><strong>（1）对象作为函数参数</strong></p>
<pre><code class="language-javascript">// 之前
const logPersonInfo = user =&gt; console.log(user.name, user.age);
logPersonInfo({name: 'jerry', age: 18});

// 之后
const logPersonInfo = ({age = 21, name = 'ZJR'}) =&gt; console.log(name, age);
logPersonInfo({name: 'jerry', age: 18});    // jerry 18
logPersonInfo({});    // ZJR 21
</code></pre>
<p><strong>（2）复杂的嵌套（主要是缕清逻辑关系即可）</strong></p>
<pre><code class="language-javascript">const obj = {
    x: 1,
    y: [2, 3, 4],
    z: {
        a: 5,
        b: 6
    }
};

// ----------------------------------------------------
const {x, y, z} = obj;
console.log(x, y, z);    // 1 [ 2, 3, 4 ] { a: 5, b: 6 }

// ----------------------------------------------------
const {y: [, y2]} = obj;
console.log(y2);    // 3
console.log(y);        // 报错

// ----------------------------------------------------
const {y: y, y: [, y2]} = obj;
console.log(y2);    // 3
console.log(y);        // [ 2, 3, 4 ]

// ----------------------------------------------------
const {y, y: [, y2], z, z: {b}} = obj;
console.log(y2);    // 3
console.log(y);        // [ 2, 3, 4 ]
console.log(z);        // { a: 5, b: 6 }
console.log(b);        // 6
</code></pre>
<p><strong>（3）剩余参数中的使用</strong></p>
<p>在对象的解构中也可以使用剩余参数，对对象中没有解构的剩余属性做聚合操作，生成一个新的对象。</p>
<pre><code class="language-js">var {a, c, ...rest} = {a: 1, b: 2, c: 3, d: 4}
console.log(a);     // 1
console.log(c);     // 3
console.log(rest);  // { b: 2, d: 4 }
</code></pre>
<p>对象中的 b、d 没有被解构，通过剩余参数语法把没有解构的对象属性聚合到一起形成新的对象。</p>
<h3 id="25-注意点">2.5 注意点</h3>
<p>（1）如果要将一个已经声明的变量用于解构赋值，必须非常小心。</p>
<pre><code class="language-js">// 错误的写法
let x;
{x} = {x: 1};
// SyntaxError: syntax error
</code></pre>
<p>上面代码的写法会报错，因为 JavaScript 引擎会将<code>{x}</code>理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。</p>
<pre><code class="language-js">// 正确的写法
let x;
({x} = {x: 1});
</code></pre>
<p>上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。关于圆括号与解构赋值的关系，参见下文。</p>
<p>（2）解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。</p>
<pre><code class="language-js">({} = [true, false]);
({} = 'abc');
({} = []);
</code></pre>
<p>上面的表达式虽然毫无意义，但是语法是合法的，可以执行。</p>
<p>（3）由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</p>
<pre><code class="language-js">let arr = [1, 2, 3];
let {0 : first, [arr.length - 1] : last} = arr;
first // 1
last // 3
</code></pre>
<p>上面代码对数组进行对象解构。数组<code>arr</code>的<code>0</code>键对应的值是<code>1</code>，<code>[arr.length - 1]</code>就是<code>2</code>键，对应的值是<code>3</code>。</p>
<h2 id="3字符串的解构赋值">3.字符串的解构赋值</h2>
<p>既可以用数组的形式来解构赋值，也可以用对象的形式来解构赋值。</p>
<pre><code class="language-javascript">// 数组形式解构赋值
const [a, b, , , c] = 'hello';
console.log(a, b, c);    // h e o

// 对象形式解构赋值
const {0: a, 1: b, 4: o, length} = 'hello';
console.log(a, b, o, length);    // h e o 5
</code></pre>
<h2 id="4数值和布尔值的解构赋值">4.数值和布尔值的解构赋值</h2>
<p>只能按照对象的形式来解构赋值。</p>
<p>（会先自动将等号右边的值转为对象）</p>
<pre><code class="language-javascript">// 先来复习一下将数值和布尔值转化为对象
console.log(new Number(123));
console.log(new Boolean(true));
// 转化后的对象里没有任何的属性（没有 123 这个属性，也没有 true 这个属性）和方法，
// 所有的属性和方法都在它的继承 __proto__ 中，比如 toString 方法就是继承来的。

// 里面的值只能是默认值，继承的方法倒是可以取到
const {a = 1, toString} = 123;
console.log(a, toString);    // 1 [Function: toString]

// 里面的值只能是默认值，继承的方法倒是可以取到
const {b = 1, toString} = true;
console.log(b, toString);    // 1 [Function: toString]
</code></pre>
<blockquote>
<p>知道有这回事即可，一般都用不到，因为没太大意义。</p>
</blockquote>
<h2 id="5undefined-和-null-没有解构赋值">5.undefined 和 null 没有解构赋值</h2>
<p>由于 undefined 和 null 无法转为对象，所以对它们进行解构赋值，都会报错。</p>
<h2 id="6小结">6.小结</h2>
<p>本节讲解了 ES6 解构赋值的使用方法，总结下来一共有以下几点：</p>
<ol>
<li>解构赋值一般针对对象和数组，如果解构对象是 <code>undefined</code> 或是 <code>null</code> 都会报错；</li>
<li>默认值的生效条件是，只有当解构的对象的值是严格模式下的 <code>undefined</code> 的情况下，默认值才会生效；</li>
<li>可以不借助中间变量来交换两个值；</li>
<li>在解构复杂的数据解构时，注意声明的对象要和目标的对象有着相同的解构形式，才能去解构目标对象。</li>
</ol>
<h1 id="04-函数的扩展">04 【函数的扩展】</h1>
<h2 id="1函数参数的默认值">1.函数参数的默认值</h2>
<h3 id="11-认识函数参数的默认值">1.1 认识函数参数的默认值</h3>
<p>调用函数的时候传参了，就用传递的参数；如果没传参，就用默认值</p>
<h3 id="12-函数参数默认值的基本用法">1.2 函数参数默认值的基本用法</h3>
<pre><code class="language-javascript">// 之前的默认值实现方式
const multiply = (x, y) =&gt; {
    if (typeof y === 'undefined') {
        y = 3;
    }
    return x * y;
};
console.log(multiply(2, 2));    // 4
console.log(multiply(2));        // 6
</code></pre>
<pre><code class="language-javascript">// ES6 默认值实现方式
const multiply = (x, y = 3) =&gt; {
    return x * y;
};
console.log(multiply(2, 2));    // 4
console.log(multiply(2));        // 6
</code></pre>
<h3 id="13-默认值的生效条件">1.3 默认值的生效条件</h3>
<p>不传参数，或者明确的传递 undefined 作为参数，只有这两种情况下，默认值才会生效。</p>
<p>注意：null 就是 null，不会使用默认值。</p>
<h3 id="14-与解构赋值默认值结合使用">1.4 与解构赋值默认值结合使用</h3>
<p>参数默认值可以与解构赋值的默认值，结合起来使用。</p>
<pre><code class="language-js">function foo({x, y = 5}) {
  console.log(x, y);
}

foo({}) // undefined 5
foo({x: 1}) // 1 5
foo({x: 1, y: 2}) // 1 2
foo() // TypeError: Cannot read property 'x' of undefined
</code></pre>
<p>上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当函数<code>foo()</code>的参数是一个对象时，变量<code>x</code>和<code>y</code>才会通过解构赋值生成。如果函数<code>foo()</code>调用时没提供参数，变量<code>x</code>和<code>y</code>就不会生成，从而报错。通过提供函数参数的默认值，就可以避免这种情况。</p>
<pre><code class="language-js">function foo({x, y = 5} = {}) {
  console.log(x, y);
}

foo() // undefined 5
</code></pre>
<p>上面代码指定，如果没有提供参数，函数<code>foo</code>的参数默认为一个空对象。</p>
<p>下面是另一个解构赋值默认值的例子。</p>
<pre><code class="language-js">function fetch(url, { body = '', method = 'GET', headers = {} }) {
  console.log(method);
}

fetch('http://example.com', {})
// &quot;GET&quot;

fetch('http://example.com')
// 报错
</code></pre>
<p>上面代码中，如果函数<code>fetch()</code>的第二个参数是一个对象，就可以为它的三个属性设置默认值。这种写法不能省略第二个参数，如果结合函数参数的默认值，就可以省略第二个参数。这时，就出现了双重默认值。</p>
<pre><code class="language-js">function fetch(url, { body = '', method = 'GET', headers = {} } = {}) {
  console.log(method);
}

fetch('http://example.com')
// &quot;GET&quot;
</code></pre>
<p>上面代码中，函数<code>fetch</code>没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量<code>method</code>才会取到默认值<code>GET</code>。</p>
<p>注意，函数参数的默认值生效以后，参数解构赋值依然会进行。</p>
<pre><code class="language-js">function f({ a, b = 'world' } = { a: 'hello' }) {
  console.log(b);
}

f() // world
</code></pre>
<p>上面示例中，函数<code>f()</code>调用时没有参数，所以参数默认值<code>{ a: 'hello' }</code>生效，然后再对这个默认值进行解构赋值，从而触发参数变量<code>b</code>的默认值生效。</p>
<h3 id="15-参数默认值的位置">1.5 参数默认值的位置</h3>
<p>通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。</p>
<pre><code class="language-js">// 例一
function f(x = 1, y) {
  return [x, y];
}

f() // [1, undefined]
f(2) // [2, undefined]
f(, 1) // 报错
f(undefined, 1) // [1, 1]

// 例二
function f(x, y = 5, z) {
  return [x, y, z];
}

f() // [undefined, 5, undefined]
f(1) // [1, 5, undefined]
f(1, ,2) // 报错
f(1, undefined, 2) // [1, 5, 2]
</code></pre>
<p>上面代码中，有默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入<code>undefined</code>。</p>
<p>如果传入<code>undefined</code>，将触发该参数等于默认值，<code>null</code>则没有这个效果。</p>
<pre><code class="language-js">function foo(x = 5, y = 6) {
  console.log(x, y);
}

foo(undefined, null)
// 5 null
</code></pre>
<p>上面代码中，<code>x</code>参数对应<code>undefined</code>，结果触发了默认值，<code>y</code>参数等于<code>null</code>，就没有触发默认值。</p>
<h3 id="16-函数参数默认值的应用">1.6 函数参数默认值的应用</h3>
<p><strong>接收很多参数的时候</strong></p>
<pre><code class="language-javascript">// 普通时候
const logUser = (username = 'zjr', age = 18, sex = 'male') =&gt; {
    console.log(username, age, sex);
};
// 需要能够记住参数的顺序，如果参数较多那么需要配合文档，使用不方便
logUser('jerry', 18, 'male');

// ------------------------------------------------------------

// 接收一个对象作为参数
// 不需要记住参数的顺序
const logUser = options =&gt; {
    console.log(options.username, options.age, options.sex);
};
logUser({
    username: 'jerry',
    age: 18,
    sex: 'male'
});

// ------------------------------------------------------------

// 再优化
const logUser = ({username, age, sex}) =&gt; {
    console.log(username, age, sex);
};

logUser({
    username: 'jerry',
    age: 18,
    sex: 'male'
});

// ------------------------------------------------------------

// 引入默认值
const logUser = ({
    username = 'zjr',
    age = 18,
    sex = 'male'
}) =&gt; {
    console.log(username, age, sex);
};

// 其实是解构赋值原理
logUser({username: 'jerry'});    // jerry 18 male

logUser({});    // zjr 18 male

logUser();        // 报错，因为这样相当于传了一个 undefined，不符合解构赋值

// ------------------------------------------------------------

// 再优化（函数默认值 + 解构赋值 + 解构赋值默认值）
const logUser = ({
    username = 'zjr',
    age = 18,
    sex = 'male'
} = {}) =&gt; {
    console.log(username, age, sex);
};
logUser();    // zjr 18 male

/* 
解释：
1、options 与 {username = 'zjr', age = 18, sex = 'male'} 互等
2、{username = 'zjr', age = 18, sex = 'male'} = {} 其实就是 options = {}
3、由于 logUser() 的实参为 undefined，所以默认值为 {}
4、再因为 {username = 'zjr', age = 18, sex = 'male'} = {} 是解构赋值
5、由于 {} 内为 undefined，所以解构赋值启用默认值
5、所以真正的形参为 {username = 'zjr', age = 18, sex = 'male'}
注明：这样做的好处是增加函数的健壮性！
*/
</code></pre>
<p><strong>某一个参数不得省略，如果省略就抛出一个错误</strong></p>
<pre><code class="language-js">function throwIfMissing() {
  throw new Error('Missing parameter');
}

function foo(mustBeProvided = throwIfMissing()) {
  return mustBeProvided;
}

foo()
// Error: Missing parameter
</code></pre>
<p>上面代码的<code>foo</code>函数，如果调用的时候没有参数，就会调用默认值<code>throwIfMissing</code>函数，从而抛出一个错误。</p>
<p>从上面代码还可以看到，参数<code>mustBeProvided</code>的默认值等于<code>throwIfMissing</code>函数的运行结果（注意函数名<code>throwIfMissing</code>之后有一对圆括号），这表明参数的默认值不是在定义时执行，而是在运行时执行。如果参数已经赋值，默认值中的函数就不会运行。</p>
<p>另外，可以将参数默认值设为<code>undefined</code>，表明这个参数是可以省略的。</p>
<pre><code class="language-js">function foo(optional = undefined) { ··· }
</code></pre>
<h2 id="2rest-参数">2.rest 参数</h2>
<h3 id="21-前言">2.1 前言</h3>
<p>剩余语法（Rest syntax 也可以叫剩余参数）看起来和展开语法完全相同都是使用 <code>...</code> 的语法糖，不同之处在于剩余参数用于解构数组和对象。从某种意义上说，剩余语法与展开语法是相反的：展开语法将数组展开为其中的各个元素，而剩余语法则是将多个元素收集起来成为一个整体。</p>
<h3 id="22-函数参数">2.2 函数参数</h3>
<p>在讲解剩余参数前，我们先来看看，剩余参数在函数参数中都解决了哪些问题？为什么会引入剩余参数的概念？</p>
<p>在 ES5 中，函数经常会传入不定参数，在传入不定参数时，ES5 的给出的解决方案是通过 <code>arguments</code> 对象来获取函数调用时传递的参数。 <code>arguments</code> 对象不是一个数组，它是一个类数组对象，所谓类数组对象，就是指可以<strong>通过索引属性访问元素</strong>并且<strong>拥有 length</strong> 属性的对象。</p>
<p>一个简单的类数组对象是长这样的:</p>
<pre><code class="language-js">var arrLike = {
  0: 'name',
  1: 'age',
  2: 'job',
  length: 3
}
</code></pre>
<p>而它所对应的数组应该是这样子的：</p>
<pre><code class="language-js">var arr = ['name', 'age', 'job'];
</code></pre>
<p>这里我们说类数组对象与数组的性质相似，是因为类数组对象在<strong>访问</strong>、<strong>赋值</strong>、<strong>获取长度</strong>上的操作与数组是一致的，具体内容可查阅相关的类数组使用。</p>
<p>在函数体中定义了 Arguments 对象，其包含函数的参数和其它属性，以 <code>arguments</code> 变量来指代。下面我们看个实例：</p>
<pre><code class="language-js">function fn() {
    console.log(arguments);
}
fn('imooc', 7, 'ES6')
</code></pre>
<p>在控制台中打印出上面的代码结果，如下图所示：在定义函数的时候没有给定参数，但是通过 <code>arguments</code> 对象可以拿到传入的参数。可以看到 <code>arguments</code> 中包含了函数传递的参数、length 等属性，length 属性表示的是实参的长度，即调用函数的时候传入的参数个数。这样我们就对 <code>arguments</code> 对象有了一定的了解。</p>
<figure data-type="image" tabindex="1"><img src="https://i0.hdslb.com/bfs/album/116b8f3318b159435aaeca5914bc5cf3dd424fdf.png" alt="image-20220826180356855" loading="lazy"></figure>
<p>在 ES5 的开发模式下，想要使用传递的参数，则需要按位置把对应的参数取出来。尽管 <code>arguments</code> 是一个类数组且可遍历的变量，但它终究不是数组，它不支持数组方法，因此我们不能调用 <code>arguments.forEeach (…)</code> 等数组的方法。需要使用一些特殊的方法转换成数组使用，如：</p>
<pre><code class="language-js">function fn() {
  var arr = [].slice.call(arguments);
  console.log(arr)
}
fn('ES6');
//  [&quot;ES6&quot;]
fn('imooc', 7, 'ES6');
//  [&quot;imooc&quot;, 7, &quot;ES6&quot;]
</code></pre>
<p>终于借助 <code>call</code> 方法把 <code>arguments</code> 转化成一个真正的数组了。但是这样无疑是一个繁琐的过程，而且不容易理解。这时 ES6 给出了它的完美解决方案 —— 剩余参数，那剩余参数是如何在函数传参中使用的呢？下面我们来看看实例：</p>
<p>语法：<code>const add = (x, y, z, ...args) =&gt; {};</code></p>
<pre><code class="language-js">function fn(...args) {
  console.log(args)
}
fn('ES6');
//  [&quot;ES6&quot;]
fn('imooc', 7, 'ES6');
//  [&quot;imooc&quot;, 7, &quot;ES6&quot;]
</code></pre>
<p>使用方式很简单在函数定义时使用 <code>...</code> 紧接着跟一个收集的参数，这个收集的参数就是我们所传入不定参数的集合 —— 也就是数组。这样就很简单地摆脱了 arguments 的束缚。另外，还可以指定一个默认的参数，如下示例：</p>
<pre><code class="language-js">function fn(name, ...args) {
  console.log(name);  // 基础参数
  console.log(args);  // 剩下的参数组成的数组
}
fn('ES6');
//    'ES6'
//    []
fn('imooc', 7, 'ES6');
//  &quot;imooc&quot;
//    [7, &quot;ES6&quot;]
</code></pre>
<p>上面的代码中给函数第一个参数，声明一个变量 name，剩余的参数会被 <code>...</code> 收集成一个数组，这就是剩余参数。引入剩余参数就是为了能替代函数内部的 <code>arguments</code>，由于 <code>arguments</code> 对象不具备数组的方法，所以很多时候在使用之前要先转换成一个数组。而剩余参数本来就是一个数组，避免了这多余的一步，使用起来既优雅又自然。</p>
<h3 id="23-注意事项">2.3 注意事项</h3>
<p><strong>箭头函数的剩余参数</strong></p>
<p>箭头函数的参数部分即使只有一个剩余参数，也不能省略圆括号。</p>
<p><code>const add = (...args) =&gt; {};</code></p>
<p><strong>使用剩余参数替代 arguments 获取实际参数</strong></p>
<ul>
<li>剩余参数是一个 “真数组”，arguments 是一个 “伪数组”</li>
<li>剩余参数的名字可以自定义</li>
</ul>
<p><strong>剩余参数的位置</strong></p>
<p>剩余参数只能是最后一个参数，之后不能再有其他参数，否则会报错。</p>
<h3 id="24-剩余参数的应用">2.4 剩余参数的应用</h3>
<p>作为数组的应用：</p>
<pre><code class="language-javascript">const add = (...args) =&gt; {
    let sum = 0;

    for (let i = 0; i &lt; args.length; i++) {
        sum += args[i];
    } // 当然此处，arguments 也可以

    return sum;
};

console.log(add());            // 0
console.log(add(1, 1));        // 2
console.log(add(1, 2, 3));    // 6
</code></pre>
<p>与解构赋值结合使用：</p>
<p>（剩余参数不一定非要作为函数参数使用）</p>
<ul>
<li>与数组解构赋值结合</li>
</ul>
<pre><code class="language-javascript">let array = [1, 2, 3, 4, 5];
let [a, b, ...others] = array;
console.log(a);                     // 1
console.log(b);                     // 2
console.log(others);         // [3,4,5]
</code></pre>
<ul>
<li>与对象解构赋值结合</li>
</ul>
<pre><code class="language-javascript">const {x, y, ...z} = {a: 3, x: 1, y: 2, b: 4};
console.log(x, y, z);
// 1 2 { a: 3, b: 4 }
// 这里的剩余参数是个对象（准确的应该叫：剩余元素）
</code></pre>
<pre><code class="language-javascript">const func = ({x, y, ...z}) =&gt; {
    console.log(x, y, z);    // 1 2 { a: 3, b: 4 }
};
func({a: 3, x: 1, y: 2, b: 4});
</code></pre>
<ul>
<li>在函数传参的时候也可以是和解构一起使用</li>
</ul>
<pre><code class="language-js">function fun(...[a, b, c]) {
  return a + b + c;
}
fun('1')          // NaN (b 和 c 都是 undefined)
fun(1, 2, 3)      // 6
fun(1, 2, 3, 4)   // 6 多余的参数不会被获取到
</code></pre>
<p>上面的代码中，a、b、c 会去解构传入参数，加上有剩余语法的作用，对应的值从数组中的项解构出来，在函数内部直接使用解构出来的参数即可。剩余语法看起来和展开语法完全相同，不同点在于，剩余参数用于解构数组和对象。</p>
<h3 id="25-小结">2.5 小结</h3>
<p>本节结合了 ES5 函数中的 <code>arguments</code> 对象引入了为什么 ES6 会引入剩余参数的概念，可以看到剩余参数所带来的好处。本节内容可以总结以下几点：</p>
<ol>
<li>剩余参数是为了能替代函数内部的 arguments 而引入的；</li>
<li>和展开语法相反，剩余参数是将多个单个元素聚集起来形成一个单独的个体的过程。</li>
</ol>
<h2 id="3箭头函数">3.箭头函数</h2>
<h3 id="31-前言">3.1 前言</h3>
<p>在编程中使用最多的就是函数，在 ES5 中是用 <code>function</code> 关键字来定义函数的，由于历史原因 <code>function</code> 定义的函数存在一些问题，如 <code>this</code> 的指向、函数参数 <code>arguments</code> 等。</p>
<p>ES6 规定了可以使用 “箭头” <code>=&gt;</code> 来定义一个函数，语法更加简洁。它没有自己的 <code>this</code>、<code>arguments</code>、<code>super</code> 或 <code>new.target</code>，箭头函数表达式更适用于那些本来需要匿名函数的地方，但它不能用作构造函数。</p>
<h3 id="32-认识箭头函数">3.2 认识箭头函数</h3>
<p>普通函数：</p>
<ul>
<li><code>function 函数名() {}</code></li>
<li><code>const 变量名 = function () {};</code></li>
</ul>
<p>箭头函数：</p>
<ul>
<li>
<p><code>参数 =&gt; 函数体</code></p>
</li>
<li>
<p><code>() =&gt; {}</code></p>
</li>
</ul>
<blockquote>
<p>由于箭头函数是匿名函数，所以我们通常把它赋给一个变量</p>
</blockquote>
<pre><code class="language-javascript">const add = (x, y) =&gt; {
    return x + y;
};

console.log(add(1, 1));        // 2
</code></pre>
<h3 id="33-箭头函数注意事项">3.3 箭头函数注意事项</h3>
<h4 id="331-省略写法">3.3.1 省略写法</h4>
<pre><code class="language-javascript">const add = (x) =&gt; {
    return x + 1;
};

// 单个参数可以省略 ()
const add = x =&gt; {
    return x + 1;
};

// 无参数
const test = () =&gt; {
    return 1;
};
//或者
const test = _ =&gt; {
    return 1;
};
</code></pre>
<h4 id="332-单行函数体">3.3.2 单行函数体</h4>
<pre><code class="language-javascript">const add = (x, y) =&gt; {
    return x + y;
};

// 单行函数体可以省略 return 和 {}，且一但省略就 return 和 {} 都要一起省略
const add = (x, y) =&gt; x + y; 
</code></pre>
<h4 id="333-单行对象">3.3.3 单行对象</h4>
<pre><code class="language-javascript">const add = (x, y) =&gt; {
    return {
        value: x + y
    };
};

// const add = (x, y) =&gt; {value: x + y};  报错！因为 {} 会产生歧义！
// () 可以将语句变为表达式，从而 {} 就可以被顺理成章解释为对象
const add = (x, y) =&gt; ({value: x + y});

// 数组就没有以上问题
const add = (x, y) =&gt; [x, y];
</code></pre>
<blockquote>
<p>推荐：一般情况最好不要简写！</p>
</blockquote>
<h3 id="34-非箭头函数中的-this-指向">3.4 非箭头函数中的 this 指向</h3>
<h4 id="341-全局作用域中的-this-指向">3.4.1 全局作用域中的 this 指向</h4>
<pre><code class="language-javascript">console.log(this);
// window
</code></pre>
<h4 id="342-一般函数非箭头函数中的-this-指向">3.4.2 一般函数（非箭头函数）中的 this 指向</h4>
<blockquote>
<p>只有在函数调用的时候 this 指向才能确定，不调用的时候，不知道指向谁。</p>
<p>this 指向和函数在哪儿没有关系，只和谁在调用有关。</p>
</blockquote>
<pre><code class="language-javascript">function add() {
    console.log(this);
}

add();    // window
// 在非严格模式下，this 其实是先指向 undefined，然后被自动转为了 window
</code></pre>
<pre><code class="language-javascript">'use strict'    // 严格模式

function add() {
    console.log(this);
}

add();    // undefined
// 在严格模式下，this 为 undefined
</code></pre>
<pre><code class="language-javascript">'use strict'    // 严格模式

function add() {
    console.log(this);
}

const calc = {
    add: add
};

calc.add();        // 上下文 this 为 calc

const adder = calc.add;
adder();        // 指向 undefined（非严格模式下指向 window）
</code></pre>
<h3 id="35-箭头函数没有-this">3.5 箭头函数没有 this</h3>
<p>在 JavaScript 中，要说让人最头疼的知识点中，this 绑定绝对算一个，这是因为 this 的绑定 ‘难以捉摸’，出错的时候还往往不知道为什么，相当反逻辑。下面我们来看一个示例：</p>
<pre><code class="language-js">var title = &quot;全局标题&quot;;
var imooc = {
    title: &quot;慕课网 ES6 Wiki&quot;,
    getTitle : function(){
        console.log(this.title);
    }
};
imooc.getTitle();        // 慕课网 ES6 Wiki
var bar = imooc.getTitle;
bar();        // 全局标题
</code></pre>
<p>通过上面的小例子的打印结果可以看出 <code>this</code> 的问题，说明 <code>this</code> 的指向是不固定的。</p>
<p>这里简单说明一下 <code>this</code> 的指向，<strong><code>this</code> 指向的是调用它的对象</strong>。例子中的 <code>this</code> 是在 getTitle 的函数中的，执行 <code>imooc.getTitle()</code> 这个方法时，调用它的对象是 <code>imooc</code>，所以 this 的指向是 <code>imooc</code>。</p>
<p>之后把 <code>imooc.getTitle</code> 方法赋给 <code>bar</code>，这里要注意的是，只是把地址赋值给了 <code>bar</code> ，并没有调用。 而 <code>bar</code> 是全局对象 <code>window</code> 下的方法，所以在执行 <code>bar</code> 方法时，调用它的是 Window 对象，所以这里打印的结果是 window 下的 title——“全局标题”。</p>
<blockquote>
<p>TIPS: 上面的示例只是简单的 <code>this</code> 指向问题，还有很多更加复杂的，在面试中经常会被问到，所以还不清楚的同学可以去研究一下 <code>this</code> 的问题。</p>
</blockquote>
<p>ES6 为了规避这样的问题，提出了箭头函数的解决方案，在箭头函数中没有自己的 <code>this</code> 指向，所有的 this 指向都指向它的上一层 <code>this</code> ，这样规定就比较容易理解了。下面看使用箭头函数下的 <code>this</code> 指向：</p>
<pre><code class="language-js">var title = &quot;全局标题&quot;;
var imooc = {
    title: &quot;慕课网 ES6 Wiki&quot;,
    getTitle : () =&gt; {
        console.log(this.title);
    }
};
imooc.getTitle();        // 全局标题
var bar = imooc.getTitle;
bar();        // 全局标题
</code></pre>
<p>上面的打印结果可以看出来，所有的 <code>this</code> 指向都指向了 window 对象下的 title，本身的 imooc 对象下没有了 <code>this</code> ，它的上一层就是 window。</p>
<h3 id="36-不适用箭头函数的场景">3.6 不适用箭头函数的场景</h3>
<h4 id="361-作为构造函数">3.6.1 作为构造函数</h4>
<p>因为箭头函数没有 this，而构造函数的核心就是 this。</p>
<h4 id="362-需要-this-指向调用对象的时候">3.6.2 需要 this 指向调用对象的时候</h4>
<p>因为箭头函数没有 this，所以如果箭头函数中出现了 this，那么这个 this 就是外层的！</p>
<h4 id="363-需要使用-arguments-的时候">3.6.3 需要使用 arguments 的时候</h4>
<p>箭头函数没有 arguments。</p>
<p>（这个问题有替代解决方案：剩余参数）</p>
<pre><code class="language-js">var fun = function() {
  console.log(arguments)
};
fun(1,2,3);  // Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]

var fun = () =&gt; {
  console.log(arguments)
};
fun(1,2,3);  // Uncaught ReferenceError: arguments is not defined
</code></pre>
<p>上面的示例中，对比两种定义函数的方法可以明显的看出，在箭头函数中去取 <code>arguments</code> 时会报引用错误，没有定义的 <code>arguments</code>。</p>
<p><code>arguments</code> 的主要作用是获取所有调用函数时所需要传入的参数，在箭头函数中使用剩余参数 <code>...args</code>，在函数内可以直接使用。</p>
<pre><code class="language-js">function foo(...args) { 
  console.log(args)
}
foo(1);         // [1]
foo(1, 2, 3);   // [1, 2, 3]
</code></pre>
<h3 id="37-其他注意点">3.7 其他注意点</h3>
<h4 id="371-不能用作构造器">3.7.1 不能用作构造器</h4>
<p>箭头函数不能用作构造器，和 new 一起用会抛出错误。</p>
<pre><code class="language-js">var Foo = () =&gt; {};
var foo = new Foo(); // TypeError: Foo is not a constructor
</code></pre>
<h4 id="372-没有-prototype-属性">3.7.2 没有 prototype 属性</h4>
<p>箭头函数没有 prototype 属性。</p>
<pre><code class="language-js">var Foo = () =&gt; {};
console.log(Foo.prototype); // undefined
</code></pre>
<h4 id="373-不能使用-yield-命令">3.7.3 不能使用 yield 命令</h4>
<p>yield 关键字通常不能在箭头函数中使用，因此箭头函数不能用作 Generator 函数。</p>
<h3 id="38-小结">3.8 小结</h3>
<p>本节主要讲解了 ES6 的箭头函数，总结了以下几点：</p>
<ul>
<li>更短的函数，优雅简洁；</li>
<li>箭头函数不会创建自己的 this，它只会从自己的作用域链的上一层继承 this；</li>
<li>不能绑定 arguments， 只能使用 <code>...args</code> 展开运算来获取当前参数的数组。</li>
</ul>
<h2 id="4函数参数的尾逗号">4.函数参数的尾逗号</h2>
<p>ES2017 允许函数的最后一个参数有尾逗号（trailing comma）。</p>
<p>此前，函数定义和调用时，都不允许最后一个参数后面出现逗号。</p>
<pre><code class="language-js">function clownsEverywhere(
  param1,
  param2
) { /* ... */ }

clownsEverywhere(
  'foo',
  'bar'
);
</code></pre>
<p>上面代码中，如果在<code>param2</code>或<code>bar</code>后面加一个逗号，就会报错。</p>
<p>如果像上面这样，将参数写成多行（即每个参数占据一行），以后修改代码的时候，想为函数<code>clownsEverywhere</code>添加第三个参数，或者调整参数的次序，就势必要在原来最后一个参数后面添加一个逗号。这对于版本管理系统来说，就会显示添加逗号的那一行也发生了变动。这看上去有点冗余，因此新的语法允许定义和调用时，尾部直接有一个逗号。</p>
<pre><code class="language-js">function clownsEverywhere(
  param1,
  param2,
) { /* ... */ }

clownsEverywhere(
  'foo',
  'bar',
);
</code></pre>
<p>这样的规定也使得，函数参数与数组和对象的尾逗号规则，保持一致了。</p>
<h2 id="5catch-命令的参数省略">5.catch 命令的参数省略</h2>
<p>JavaScript 语言的<code>try...catch</code>结构，以前明确要求<code>catch</code>命令后面必须跟参数，接受<code>try</code>代码块抛出的错误对象。</p>
<pre><code class="language-js">try {
  // ...
} catch (err) {
  // 处理错误
}
</code></pre>
<p>上面代码中，<code>catch</code>命令后面带有参数<code>err</code>。</p>
<p>很多时候，<code>catch</code>代码块可能用不到这个参数。但是，为了保证语法正确，还是必须写。ES2019做出了改变，允许<code>catch</code>语句省略参数。</p>
<pre><code class="language-js">try {
  // ...
} catch {
  // ...
}
</code></pre>

                        </div>
                        
                            <div class="post-toc">
                                <ul class="markdownIt-TOC">
<li><a href="#01-es6-%E4%BB%8B%E7%BB%8D">01 【ES6 介绍】</a>
<ul>
<li><a href="#1ecmascript-%E5%92%8C-javascript-%E7%9A%84%E5%85%B3%E7%B3%BB">1.ECMAScript 和 JavaScript 的关系</a></li>
<li><a href="#2es6-%E4%B8%8E-ecmascript-2015-%E7%9A%84%E5%85%B3%E7%B3%BB">2.ES6 与 ECMAScript 2015 的关系</a></li>
<li><a href="#3es6%E7%AE%80%E4%BB%8B">3.ES6简介</a></li>
</ul>
</li>
<li><a href="#02-let%E5%92%8Cconst">02 【let和const】</a>
<ul>
<li><a href="#1let-%E5%91%BD%E4%BB%A4">1.let 命令</a>
<ul>
<li><a href="#11-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">1.1 基本用法</a></li>
<li><a href="#12-%E4%B8%8D%E5%AD%98%E5%9C%A8%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87">1.2 不存在变量提升</a></li>
<li><a href="#13-%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA">1.3 暂时性死区</a></li>
<li><a href="#14-%E4%B8%8D%E5%85%81%E8%AE%B8%E9%87%8D%E5%A4%8D%E5%A3%B0%E6%98%8E">1.4 不允许重复声明</a></li>
</ul>
</li>
<li><a href="#2%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F">2.块级作用域</a>
<ul>
<li><a href="#21-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F">2.1 为什么需要块级作用域？</a></li>
<li><a href="#22-es6-%E7%9A%84%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F">2.2 ES6 的块级作用域</a></li>
<li><a href="#23-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E">2.3 块级作用域与函数声明</a></li>
</ul>
</li>
<li><a href="#3const-%E5%91%BD%E4%BB%A4">3.const 命令</a>
<ul>
<li><a href="#31-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">3.1 基本用法</a></li>
<li><a href="#32-%E6%9C%AC%E8%B4%A8">3.2 本质</a></li>
<li><a href="#33-window-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%AD">3.3  window 对象的属性和方法（全局作用域中）</a></li>
<li><a href="#34-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8-let%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%94%A8-const">3.4 什么时候用 let，什么使用用 const</a></li>
</ul>
</li>
<li><a href="#4let%E5%92%8Cconst%E6%80%BB%E7%BB%93">4.let和const总结</a></li>
<li><a href="#5%E9%A1%B6%E5%B1%82%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7">5.顶层对象的属性</a></li>
</ul>
</li>
<li><a href="#03%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC">03【解构赋值】</a>
<ul>
<li><a href="#1%E6%95%B0%E7%BB%84%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC">1.数组的解构赋值</a>
<ul>
<li><a href="#11-%E5%8E%9F%E7%90%86">1.1 原理</a></li>
<li><a href="#12-%E6%95%B0%E7%BB%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC">1.2 数组解构赋值的默认值</a></li>
<li><a href="#13-%E6%95%B0%E7%BB%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E7%9A%84%E5%BA%94%E7%94%A8">1.3 数组解构赋值的应用</a></li>
<li><a href="#14-%E5%BF%85%E9%A1%BB%E8%A6%81%E5%88%86%E5%8F%B7%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%83%85%E5%86%B5">1.4 必须要分号的两种情况</a></li>
</ul>
</li>
<li><a href="#2%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC">2.对象的解构赋值</a>
<ul>
<li><a href="#21-%E5%8E%9F%E7%90%86">2.1 原理</a></li>
<li><a href="#22-%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC">2.2 对象解构赋值的默认值</a></li>
<li><a href="#23-%E9%87%8D%E5%91%BD%E5%90%8D%E5%B1%9E%E6%80%A7">2.3 重命名属性</a></li>
<li><a href="#24-%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E7%9A%84%E5%BA%94%E7%94%A8">2.4 对象解构赋值的应用</a></li>
<li><a href="#25-%E6%B3%A8%E6%84%8F%E7%82%B9">2.5 注意点</a></li>
</ul>
</li>
<li><a href="#3%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC">3.字符串的解构赋值</a></li>
<li><a href="#4%E6%95%B0%E5%80%BC%E5%92%8C%E5%B8%83%E5%B0%94%E5%80%BC%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC">4.数值和布尔值的解构赋值</a></li>
<li><a href="#5undefined-%E5%92%8C-null-%E6%B2%A1%E6%9C%89%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC">5.undefined 和 null 没有解构赋值</a></li>
<li><a href="#6%E5%B0%8F%E7%BB%93">6.小结</a></li>
</ul>
</li>
<li><a href="#04-%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95">04 【函数的扩展】</a>
<ul>
<li><a href="#1%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC">1.函数参数的默认值</a>
<ul>
<li><a href="#11-%E8%AE%A4%E8%AF%86%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC">1.1 认识函数参数的默认值</a></li>
<li><a href="#12-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95">1.2 函数参数默认值的基本用法</a></li>
<li><a href="#13-%E9%BB%98%E8%AE%A4%E5%80%BC%E7%9A%84%E7%94%9F%E6%95%88%E6%9D%A1%E4%BB%B6">1.3 默认值的生效条件</a></li>
<li><a href="#14-%E4%B8%8E%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E9%BB%98%E8%AE%A4%E5%80%BC%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8">1.4 与解构赋值默认值结合使用</a></li>
<li><a href="#15-%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC%E7%9A%84%E4%BD%8D%E7%BD%AE">1.5 参数默认值的位置</a></li>
<li><a href="#16-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC%E7%9A%84%E5%BA%94%E7%94%A8">1.6 函数参数默认值的应用</a></li>
</ul>
</li>
<li><a href="#2rest-%E5%8F%82%E6%95%B0">2.rest 参数</a>
<ul>
<li><a href="#21-%E5%89%8D%E8%A8%80">2.1 前言</a></li>
<li><a href="#22-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0">2.2 函数参数</a></li>
<li><a href="#23-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">2.3 注意事项</a></li>
<li><a href="#24-%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8">2.4 剩余参数的应用</a></li>
<li><a href="#25-%E5%B0%8F%E7%BB%93">2.5 小结</a></li>
</ul>
</li>
<li><a href="#3%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0">3.箭头函数</a>
<ul>
<li><a href="#31-%E5%89%8D%E8%A8%80">3.1 前言</a></li>
<li><a href="#32-%E8%AE%A4%E8%AF%86%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0">3.2 认识箭头函数</a></li>
<li><a href="#33-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">3.3 箭头函数注意事项</a>
<ul>
<li><a href="#331-%E7%9C%81%E7%95%A5%E5%86%99%E6%B3%95">3.3.1 省略写法</a></li>
<li><a href="#332-%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0%E4%BD%93">3.3.2 单行函数体</a></li>
<li><a href="#333-%E5%8D%95%E8%A1%8C%E5%AF%B9%E8%B1%A1">3.3.3 单行对象</a></li>
</ul>
</li>
<li><a href="#34-%E9%9D%9E%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84-this-%E6%8C%87%E5%90%91">3.4 非箭头函数中的 this 指向</a>
<ul>
<li><a href="#341-%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%AD%E7%9A%84-this-%E6%8C%87%E5%90%91">3.4.1 全局作用域中的 this 指向</a></li>
<li><a href="#342-%E4%B8%80%E8%88%AC%E5%87%BD%E6%95%B0%E9%9D%9E%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84-this-%E6%8C%87%E5%90%91">3.4.2 一般函数（非箭头函数）中的 this 指向</a></li>
</ul>
</li>
<li><a href="#35-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E6%B2%A1%E6%9C%89-this">3.5 箭头函数没有 this</a></li>
<li><a href="#36-%E4%B8%8D%E9%80%82%E7%94%A8%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84%E5%9C%BA%E6%99%AF">3.6 不适用箭头函数的场景</a>
<ul>
<li><a href="#361-%E4%BD%9C%E4%B8%BA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">3.6.1 作为构造函数</a></li>
<li><a href="#362-%E9%9C%80%E8%A6%81-this-%E6%8C%87%E5%90%91%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%97%B6%E5%80%99">3.6.2 需要 this 指向调用对象的时候</a></li>
<li><a href="#363-%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8-arguments-%E7%9A%84%E6%97%B6%E5%80%99">3.6.3 需要使用 arguments 的时候</a></li>
</ul>
</li>
<li><a href="#37-%E5%85%B6%E4%BB%96%E6%B3%A8%E6%84%8F%E7%82%B9">3.7 其他注意点</a>
<ul>
<li><a href="#371-%E4%B8%8D%E8%83%BD%E7%94%A8%E4%BD%9C%E6%9E%84%E9%80%A0%E5%99%A8">3.7.1 不能用作构造器</a></li>
<li><a href="#372-%E6%B2%A1%E6%9C%89-prototype-%E5%B1%9E%E6%80%A7">3.7.2 没有 prototype 属性</a></li>
<li><a href="#373-%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8-yield-%E5%91%BD%E4%BB%A4">3.7.3 不能使用 yield 命令</a></li>
</ul>
</li>
<li><a href="#38-%E5%B0%8F%E7%BB%93">3.8 小结</a></li>
</ul>
</li>
<li><a href="#4%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E5%B0%BE%E9%80%97%E5%8F%B7">4.函数参数的尾逗号</a></li>
<li><a href="#5catch-%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8F%82%E6%95%B0%E7%9C%81%E7%95%A5">5.catch 命令的参数省略</a></li>
</ul>
</li>
</ul>

                            </div>
                            
                                
                                                    
                                                                    <!--Share-->
                                                                    <span style="margin-right:15px">
                        <i class="post-share"></i>
                        <span>&#x5206;&#x4EAB;:</span>
                                                                    <a title="QR 码" target="_blank" href="https://api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://2022FuGui.github.io/post/es6-jie-shao/"><i class="fa fa-qrcode"></i></a>
                                                                    <a title="QQ" target="_blank" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://2022FuGui.github.io/post/es6-jie-shao/&sharesource=qzone&title=ES6&pics=https://2022FuGui.github.io/images/avatar.png?v=1729699091091&summary=&lt;h1 id=&#34;01-es6-介绍&#34;&gt;01 【ES6 介绍】&lt;/h1&gt;
&lt;p&gt;ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。&lt;/p&gt;
&lt;h2 id=&#34;1ecmascript-和-javascript-的关系&#34;&gt;1.ECMAScript 和 JavaScript 的关系&lt;/h2&gt;
&lt;p&gt;一个常见的问题是，ECMAScript 和 JavaScript 到底是什么关系？&lt;/p&gt;
&lt;p&gt;要讲清楚这个问题，需要回顾历史。1996 年 11 月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给标准化组织 ECMA，希望这种语言能够成为国际标准。次年，ECMA 发布 262 号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript，这个版本就是 1.0 版。&lt;/p&gt;
&lt;p&gt;该标准从一开始就是针对 JavaScript 语言制定的，但是之所以不叫 JavaScript，有两个原因。一是商标，Java 是 Sun 公司的商标，根据授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且 JavaScript 本身也已经被 Netscape 公司注册为商标。二是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。&lt;/p&gt;
&lt;p&gt;因此，ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 JScript 和 ActionScript）。日常场合，这两个词是可以互换的。&lt;/p&gt;
&lt;h2 id=&#34;2es6-与-ecmascript-2015-的关系&#34;&gt;2.ES6 与 ECMAScript 2015 的关系&lt;/h2&gt;
&lt;p&gt;ECMAScript 2015（简称 ES2015）这个词，也是经常可以看到的。它与 ES6 是什么关系呢？&lt;/p&gt;
&lt;p&gt;2011 年，ECMAScript 5.1 版发布后，就开始制定 6.0 版了。因此，ES6 这个词的原意，就是指 JavaScript 语言的下一个版本。&lt;/p&gt;
&lt;p&gt;但是，因为这个版本引入的语法功能太多，而且制定过程当中，还有很多组织和个人不断提交新功能。事情很快就变得清楚了，不可能在一个版本里面包括所有将要引入的功能。常规的做法是先发布 6.0 版，过一段时间再发 6.1 版，然后是 6.2 版、6.3 版等等。&lt;/p&gt;
&lt;p&gt;但是，标准的制定者不想这样做。他们想让标准的升级成为常规流程：任何人在任何时候，都可以向标准委员会提交新语法的提案，然后标准委员会每个月开一次会，评估这些提案是否可以接受，需要哪些改进。如果经过多次会议以后，一个提案足够成熟了，就可以正式进入标准了。这就是说，标准的版本升级成为了一个不断滚动的流程，每个月都会有变动。&lt;/p&gt;
&lt;p&gt;标准委员会最终决定，标准在每年的 6 月份正式发布一次，作为当年的正式版本。接下来的时间，就在这个版本的基础上做改动，直到下一年的 6 月份，草案就自然变成了新一年的版本。这样一来，就不需要以前的版本号了，只要用年份标记就可以了。&lt;/p&gt;
&lt;p&gt;ES6 的第一个版本，就这样在 2015 年 6 月发布了，正式名称就是《ECMAScript 2015 标准》（简称 ES2015）。2016 年 6 月，小幅修订的《ECMAScript 2016 标准》（简称 ES2016）如期发布，这个版本可以看作是 ES6.1 版，因为两者的差异非常小（只新增了数组实例的&lt;code&gt;includes&lt;/code&gt;方法和指数运算符），基本上是同一个标准。根据计划，2017 年 6 月发布 ES2017 标准。&lt;/p&gt;
&lt;p&gt;因此，ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。本书中提到 ES6 的地方，一般是指 ES2015 标准，但有时也是泛指“下一代 JavaScript 语言”。&lt;/p&gt;
&lt;h2 id=&#34;3es6简介&#34;&gt;3.ES6简介&lt;/h2&gt;
&lt;p&gt;ES6 = ECMAScript 这门标准的第 6 代版本（2015）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ECMAScript 是语言的标准&lt;/li&gt;
&lt;li&gt;6 是版本号&lt;/li&gt;
&lt;/ul&gt;
"><i class="fa fa-qq"></i></a>
                                                                    <a title="新浪微博" target="_blank" href="https://service.weibo.com/share/share.php?url=https://2022FuGui.github.io/post/es6-jie-shao/&sharesource=weibo&title=ES6 + " - " + &lt;h1 id=&#34;01-es6-介绍&#34;&gt;01 【ES6 介绍】&lt;/h1&gt;
&lt;p&gt;ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。&lt;/p&gt;
&lt;h2 id=&#34;1ecmascript-和-javascript-的关系&#34;&gt;1.ECMAScript 和 JavaScript 的关系&lt;/h2&gt;
&lt;p&gt;一个常见的问题是，ECMAScript 和 JavaScript 到底是什么关系？&lt;/p&gt;
&lt;p&gt;要讲清楚这个问题，需要回顾历史。1996 年 11 月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给标准化组织 ECMA，希望这种语言能够成为国际标准。次年，ECMA 发布 262 号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript，这个版本就是 1.0 版。&lt;/p&gt;
&lt;p&gt;该标准从一开始就是针对 JavaScript 语言制定的，但是之所以不叫 JavaScript，有两个原因。一是商标，Java 是 Sun 公司的商标，根据授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且 JavaScript 本身也已经被 Netscape 公司注册为商标。二是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。&lt;/p&gt;
&lt;p&gt;因此，ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 JScript 和 ActionScript）。日常场合，这两个词是可以互换的。&lt;/p&gt;
&lt;h2 id=&#34;2es6-与-ecmascript-2015-的关系&#34;&gt;2.ES6 与 ECMAScript 2015 的关系&lt;/h2&gt;
&lt;p&gt;ECMAScript 2015（简称 ES2015）这个词，也是经常可以看到的。它与 ES6 是什么关系呢？&lt;/p&gt;
&lt;p&gt;2011 年，ECMAScript 5.1 版发布后，就开始制定 6.0 版了。因此，ES6 这个词的原意，就是指 JavaScript 语言的下一个版本。&lt;/p&gt;
&lt;p&gt;但是，因为这个版本引入的语法功能太多，而且制定过程当中，还有很多组织和个人不断提交新功能。事情很快就变得清楚了，不可能在一个版本里面包括所有将要引入的功能。常规的做法是先发布 6.0 版，过一段时间再发 6.1 版，然后是 6.2 版、6.3 版等等。&lt;/p&gt;
&lt;p&gt;但是，标准的制定者不想这样做。他们想让标准的升级成为常规流程：任何人在任何时候，都可以向标准委员会提交新语法的提案，然后标准委员会每个月开一次会，评估这些提案是否可以接受，需要哪些改进。如果经过多次会议以后，一个提案足够成熟了，就可以正式进入标准了。这就是说，标准的版本升级成为了一个不断滚动的流程，每个月都会有变动。&lt;/p&gt;
&lt;p&gt;标准委员会最终决定，标准在每年的 6 月份正式发布一次，作为当年的正式版本。接下来的时间，就在这个版本的基础上做改动，直到下一年的 6 月份，草案就自然变成了新一年的版本。这样一来，就不需要以前的版本号了，只要用年份标记就可以了。&lt;/p&gt;
&lt;p&gt;ES6 的第一个版本，就这样在 2015 年 6 月发布了，正式名称就是《ECMAScript 2015 标准》（简称 ES2015）。2016 年 6 月，小幅修订的《ECMAScript 2016 标准》（简称 ES2016）如期发布，这个版本可以看作是 ES6.1 版，因为两者的差异非常小（只新增了数组实例的&lt;code&gt;includes&lt;/code&gt;方法和指数运算符），基本上是同一个标准。根据计划，2017 年 6 月发布 ES2017 标准。&lt;/p&gt;
&lt;p&gt;因此，ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。本书中提到 ES6 的地方，一般是指 ES2015 标准，但有时也是泛指“下一代 JavaScript 语言”。&lt;/p&gt;
&lt;h2 id=&#34;3es6简介&#34;&gt;3.ES6简介&lt;/h2&gt;
&lt;p&gt;ES6 = ECMAScript 这门标准的第 6 代版本（2015）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ECMAScript 是语言的标准&lt;/li&gt;
&lt;li&gt;6 是版本号&lt;/li&gt;
&lt;/ul&gt;
&pic="https://2022FuGui.github.io/images/avatar.png?v=1729699091091 "><i class="fa fa-weibo "></i></a>

                                                                    </span>
                                                                    
                                                                            <!--zh-->
                                                                            <section class="post-tags zh ">
                                                                                <div>
                                                                                    <span>&#x6807;&#x7B7E;:</span>
                                                                                    <span class="tag ">
                        
                        
                        <a href="https://2022FuGui.github.io/tag/wTb2n121Vj/">#
                    JS
                        </a>
                        
                        <a href="https://2022FuGui.github.io/tag/5d3oKlLxgj/">#
                    前端
                        </a>
                        
                            
                                </span>
                                                                                </div>
                                                                                <div>
                                                                                    <a href="javascript:window.history.back();">
                        &#x8FD4;&#x56DE;</a>
                                                                                    <span>&dot;</span>
                                                                                    <a href="#">&#x4E3B;&#x9875;</a>
                                                                                </div>
                                                                            </section>

                                                                            
                                                                                <!---->
                                                                                <section class="post-nav">
                                                                                    
                                                                                        <a class="prev" rel="prev" href="https://2022FuGui.github.io/post/juc-xue-xi/">
                                                                                            JUC学习
                                                                                        </a>
                                                                                        
                                                                                            
                                                                                                <a class="next" rel="next" href="https://2022FuGui.github.io/post/lan-qiao-bei-bei-zhan/">
                                                                                                    蓝桥杯备战
                                                                                                </a>
                                                                                                
                                                                                </section>
                    </article>
                </div>
                
                                            
            </div>
    </div>
    </div>
    </div>
    
        <footer id="footer" class="footer">
            <div class="copyright">
                
                        Powered by 2022FuGui
                            
                                <b id="hitokoto"></b><br>
                                
                                        <svg viewBox="0 0 1024 1024" style="margin-left: 5px;margin-right: 5px;" version="1.0" width="8" height="8" class="my-face">
            <path
                d="M863.597631 513.574282l-271.33965-140.213484L729.783667 81.926656c3.583731-7.87141 7.167462-15.742819 7.167462-25.214109C736.887134 25.226908 708.345275 0.012799 672.635953 0.012799a63.611229 63.611229 0 0 0-39.293053 12.607055c-1.791866 1.59988-3.519736 3.19976-5.311602 3.19976L147.87531 418.925381a55.547834 55.547834 0 0 0-19.646527 47.356448c1.791866 17.278704 14.27093 33.021523 32.125591 42.492813l271.33965 141.749369L292.504463 945.221908c-12.479064 25.214109-1.791866 53.563983 23.166262 69.306802 10.751194 6.335525 23.230258 9.47129 35.709322 9.47129 16.062795 0 32.125591-4.735645 44.604655-15.742819l480.091993-403.297753a55.547834 55.547834 0 0 0 19.646526-47.228458 61.243407 61.243407 0 0 0-32.12559-44.156688z"
                fill="#93b5cf"></path>
        </svg>
                                        雁南飞无留意 &copy;Copyright
                                            <script>
                                                var date = new Date();
                                                document.write("" + date.getFullYear());
                                            </script>
                                            | Powered by
                                            <a href="#" target="_blank">
                                                雁南飞无留意
                                            </a>
            </div>
            <div id="update" style="display:none;">
                on
            </div>
            
                <div id="version" style="display:none;">
                    1.7.6
                </div>
                
                    <script>
                        var port = '';
                        
                        document.write('<div id="home_path" style="display:none;">' + document.location.protocol + '//' + window.document.location.hostname + port + '</div>')
                    </script>
        </footer>
        
            <script src='https://fastly.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js'></script>
            
                <script>
                    
                    
                    loadlive2d();
                    
                    
                    hitokoto();
                    
                    getStar();
                    hljs.initHighlighting();
                    console.clear();
                    
                    CheckVersion();
                    
                    var newDate = new Date();
                    newDate.setTime(1729699091091);
                    console.log(" Blog Update Time: " + newDate.toLocaleDateString());
                    console.log("\n %c \u26a1Theme:Chic Author's Blog:https://blog.itjoker.cn  Write By ITJoker  \n\n", "color: #ffffff; background: rgba(49, 49, 49, 0.85); padding:5px 0;border-radius:5px;");
                </script>
        </div>
</body>
<script>
    scroll();
</script>

</html>